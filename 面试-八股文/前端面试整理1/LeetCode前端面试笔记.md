[TOC]





## 一、HTML

### 题组1：

#### 1、`<img>`标签上 `title` 属性和 `alt` 属性的区别是什么 ？

答案：alt 属性是为了给那些不能看到你文档中图像的浏览者提供文字说明的。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短。这包括那些使用本来就不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户等。title属性为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息。

**alt: 是图片加载失败时的文字说明；**

**title: 是鼠标悬停在图片上时给出的提示信息。**



#### 2、请写出至少 5 个 html5 新增的标签，并说明其语义和应用场景

`section`：定义文档中的一个章节

`nav`：定义只包含导航链接的章节

`header`：定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。

`footer`：定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。

`aside`：定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。

`audio、video`等



#### 3. 请说说你对标签语义化的理解？

a. 去掉或者丢失样式的时候能够让页面呈现出清晰的结构

b. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重

c. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页

d. 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化



#### 4. Doctype 作用？严格模式与混杂模式如何区分？它们有何意义？

声明位于文档中的最前面，处于标签之前。告知浏览器以何种模式来渲染文档。严格模式的排版和 JS 运作模式是，以该浏览器支持的最高标准运行。在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。



#### 5. 你知道多少种 Doctype 文档类型？

标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页， Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。



#### 6. HTML 与 XHTML —— 二者有什么区别？

a. XHTML 元素必须被正确地嵌套。

 b. XHTML 元素必须被关闭。 

c. 标签名必须用小写字母。

 d. XHTML 文档必须拥有根元素。



#### 7. Html5 有哪些新特性、移除了那些元素？

**新特性：**

a. HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加；

b. 拖拽释放(Drag and drop) API；

c. 语义化更好的内容标签（header, nav, footer, aside, article, section）；

d. 音频、视频API(audio,video)；

e. 画布(Canvas) API；

f. 地理(Geolocation) API；

g. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；

h. sessionStorage 的数据在页面会话结束时会被清除；

i. 表单控件，calendar、date、time、email、url、search；

j. 新的技术webworker, websocket等

**移除的元素：**

a. 纯表现的元素：basefont、big、center、s、strike、tt、u；

b. 对可用性产生负面影响的元素：frame、frameset、noframes



#### 8、Iframe 的优缺点？

**优点：**

-  解决加载缓慢的第三方内容如图标和广告等的加载问题 
-  iframe无刷新文件上传 c. iframe跨域通信

**缺点：**

-  iframe会阻塞主页面的Onload事件 
-  无法被一些搜索引擎索引到 
-  页面会增加服务器的http请求 
-  会产生很多页面，不容易管理。



#### 9. Quirks(怪异) 模式是什么？

在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。IE6以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。



#### 10.请阐述 table 的缺点

a. 太深的嵌套，比如table>tr>td>h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了冗余代码量。

b. 灵活性差，比如要将tr设置border等属性，是不行的，得通过td

c. 代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱

d. 混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱。

e. 不够语义



#### 11、简述一下 src 与 href 的区别

src用于替换当前元素；href用于在当前文档和引用资源之间确立联系。

src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接





### 题组2：

#### 1、Doctype 作用？

DOCTYPE 是用来声明文档类型和 DTD 规范的。 <!DOCTYPE html>声明位于 HTML 文档中的第一行，不是一个 HTML 标签，处于 html 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。



#### 2. 标准模式与兼容模式各有什么区别？

标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 在 HTML4.01 中声明指向一个 DTD，由于 HTML4.01 基于 SGML，所以 DTD 指定了标记规则以保证浏览器正确渲染内容 HTML5 不基于 SGML，所以不用指定 DTD



#### 3、 行内元素有哪些？块级元素有哪些？ 空（void）元素有那些？

行内元素有：a b span img input select strong（强调的语气）

块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p

空元素：

常见: br hr img input link meta

不常见: area base col command embed keygen param source track wbr



#### 4、页面导入样式时，使用 link 和 @import 有什么区别？

link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS, 定义 rel 连接属性等作用；而@import 是 CSS 提供的，只能用于加载 CSS; 页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载; import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题; link 支持使用 js 控制 DOM 去改变样式，而@import 不支持



#### 5、介绍一下你对浏览器内核的理解？

主要分成两部分：渲染引擎 (layout engineer 或 Rendering Engine) 和 JS 引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后渲染到用户的屏幕上。 JS 引擎则：解析和执行 javascript 来实现逻辑和控制 DOM 进行交互。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。



#### 6、为什么我们要弃用 table 标签？

table 的缺点在于服务器把代码加载到本地服务器的过程中，本来是加载一行执行一行，但是 table 标签是里面的东西全都下载完之后才会显示出来，那么如果图片很多的话就会导致网页一直加载不出来，除非所有的图片和内容都加载完。如果要等到所有的图片全都加载完之后才显示出来的话那也太慢了，所以 table 标签现在我们基本放弃使用了。



#### 7、Quirks 模式和 Standards 模式有什么区别？

总体会有布局、样式解析和脚本执行三个方面的区别。

盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。

设置行内元素的高宽：在Standards模式下，给等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。

设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用margin:0 auto设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。



#### 8、 strong 与 em 的异同？

strong：粗体强调标签，强调，表示内容的重要性

em：斜体强调标签，更强烈强调，表示内容的强调点



#### 9、div + css 的布局较 table 布局有什么优点？

改版的时候更方便 只要改css文件。

页面加载速度更快、结构化清晰、页面显示简洁。

表现与结构相分离。

易于优化（seo）搜索引擎更友好，排名更容易靠前



#### 10、为什么利用多个域名来存储网站资源会更有效？

CDN缓存更方便

突破浏览器并发限制

节约cookie带宽

节约主域名的连接数，优化页面响应速度

防止不必要的安全问题



#### 11、请描述一下 cookies，sessionStorage 和 localStorage 的区别？

sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
Web storage和cookie的区别

Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。

除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。





## 二、CSS

### 题组1：

#### 1、如何理解CSS盒模型

标准盒子模型：宽度=内容的宽度（content）+ border + padding

低版本IE盒子模型：宽度=内容宽度（content+border+padding）



#### 2、CSS 与 JavaScript 引入设置？

`script`标签的引入一般放在body最后，这样避免脚本过大，加载时间长，导致页面长时间空白，这是因为渲染进程与js进程是互斥的，脚本会阻塞页面的渲染，脚本之间的加载是同步进行的，按引入顺序执行，但是以下两个属性会影响脚本执行与页面渲染的顺序defer：不会阻塞渲染，这样即使放在header内部，也不会阻塞页面加载，不过js会先于document加载完成，并且也不会影响脚本之间的执行顺序，按照引入顺序执行。

async：与defer一样，都是解决阻塞渲染，但它是在document加载完成后才执行，并且它的执行顺序是按照谁先加载完成执行谁，所以对于文件顺序有要求，存在前后依赖的不要使用它。



#### 3、如何实现元素隐藏？

display：none 不占位，源码可见

opacity: 0 占位，源码可见，透明度0

visibility: hidden 占位，源码可见

position: top:-9999px,left:-9999px 利用定位将元素移出视窗

宽高设为0.



#### 4、如何实现元素水平居中？

行内元素：text-align：center

块元素: margin: 0 auto

position: left: 50%; transform: translate(-50%)



#### 5、如何实现元素垂直居中？

height = line-height  (单行文字：行高 = 盒子高度)

verticle-align: middle  

position: top: 50%; transform: translate(0,-50%)



#### 6、Position 有哪些属性值？

static 默认

relative 相对定位，不脱标，相对于自身位置进行偏离，不影响元素本身特性，z-index提升层级

absolute 绝对定位，脱标，相对于已有定位的父元素进行偏离，都没有就相对于body进行偏离

fixed 固定定位，脱标，相对于视窗进行偏离



#### 7、 定位元素水平垂直居中？

宽高固定 position: top:0,left:0,right:0,bottom:0,margin:auto

宽高固定 position：top: 50%, left: 50%, margin-left: -width/2px,margin-top: -height/2px

dispaly: flex; justify-content: center,align-items: center(极力推荐)

position: left: 50%,top: 50%; transform: translate(-50%,-50%)



#### 8、CSS 选择器有哪些，选择器的优先级？

id选择器

类选择器

属性选择器

伪类选择器

标签选择器

伪元素选择器

通配符选择器

优先级：内联样式 > ID选择器(100)> 类选择器(10) = 属性选择器 = 伪类选择器 > 元素选择器 (1) = 关系选择器 = 伪元素选择器 > 通配符选择器(0)



#### 9、各种布局优缺点？

1. float 布局
    优点： 比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的

  缺点： 浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度 塌陷等。

2. 绝对布局
    优点：很快捷，设置很方便，而且也不容易出问题

  缺点：绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比 较差的。

3. flex 布局
    优点：简单快捷

  缺点：不支持 IE8 及以下

4. table布局
    优点：实现简单，代码少

  缺点：当其中一个单元格高度超出的时候，两侧的单元格也是 会跟着一起变高的，而有时候这种效果不是我们想要的。

5. grid布局
    跟 flex 相似。



#### 10、解释下浮动和它的工作原理？清除浮动的方法？

浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。

1.使用空标签清除浮动。

​		这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both.   弊端就是增加了无意义标签。

2.使用after伪对象清除浮动

3.设置overflow为hidden或者auto

4.浮动外部元素



## 三、JavaScript

### 题组1：

#### 1、为什么 JS 是单线程的？

因为JS里面有可视的Dom，如果是多线程的话，这个线程正在删除DOM节点，另一个线程正在编辑Dom节点，导致浏览器不知道该听谁的



#### 2、JS 是如何实现异步编程的？

1.回调函数callback

​	优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等待，会拖延整个程序的执行）

​	缺点：回调地狱，不能用 try catch 捕获错误，不能 return



​	优点：解决了回调地狱的问题

​	缺点：无法取消 Promise，错误需要通过回调函数来捕获

3.async/await

​	优点：代码清晰，不像 Promise 写一堆 then 链，处理了回调地狱的问题

​	缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能降低



#### 3、宏任务和微任务都有哪些？

宏任务：script、setTimeOut、setInterval、setImmediate

微任务:promise.then,process.nextTick、Object.observe、MutationObserver

注意：Promise是同步任务



#### 4、宏任务和微任务都是怎样执行的？

执行宏任务script， 进入script后，所有的同步任务主线程执行 所有宏任务放入宏任务执行队列

所有微任务放入微任务执行队列

先清空微任务队列， 再取一个宏任务，执行，再清空微任务队列

依次循环



#### 5、为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？

防止命名冲突

更好的分离，按需加载

更好的复用性

更高的维护性



#### 6、exports 和 module.exports 有什么区别？

导出方式不一样

exports.xxx='xxx';  (一次只能导出一个，可以导出多个)

module.export = {};  (只能导出一次，导出多次的话后导出的会把前面导出的覆盖)

exports是module.exports的引用，两个指向的是用一个地址，而require能看到的只有module.exports



#### 7、JS 模块包装格式有哪些？

- commonjs

​	同步运行，不适合前端

- AMD

​	异步运行

​	异步模块定义，主要采用异步的方式加载模块，模块的加载不影响后面代码的执行。所有依赖这个模块的语句都写在一个回调函数中，模块加载完毕，再执行回调函数

- CMD

​	异步运行

​	seajs 规范



#### 8、ES6 和 commonjs 的区别？

commonjs模块输出的是值的拷贝，而ES6输出的值是值的引用

commonjs是在运行时加载，是一个对象，ES6是在编译时加载，是一个代码块

commonjs的this指向当前模块，ES6的this指向undefined



#### 9、说说你知道的状态码？

2开头的表示成功，一般见到的就是200

3开头的表示重定向

​	301永久重定向

​	302临时重定向

​	304表示可以在缓存中取数据（协商缓存）

4开头表示客户端错误

​	403跨域

​	404请求资源不存在

5开头表示服务端错误

​	500



#### 10、什么是闭包？

能够读取其他函数内部变量的函数。

或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。



### 题组2：

#### 1、闭包的用途？

1、读取函数内部的变量

2、让这些变量的值始终保持在内存中。不会再f1调用后被自动清除。

3、方便调用上下文的局部变量。利于代码封装。

原因：f1是f2的父函数，f2被赋给了一个全局变量，f2始终存在内存中，f2的存在依赖f1，因 此f1也始终存在内存中，不会在调用结束后，被垃圾回收机制回收。



#### 2、 闭包的缺点？

1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则 会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象 （object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属 性（private value），这时一定要小心，不要随便改变父函数内部变量的值。



#### 3、JS 有哪些数据类型

根据 JavaScript 中的变量类型传递方式，分为基本数据类型和引用数据类型两大类七种。

基本数据类型包括Undefined、Null、Boolean、Number、String、Symbol (ES6新增)六种。

引用数据类型只有Object一种，主要包括对象、数组和函数。



#### 4、基本数据类型和引用数据类型有什么区别？

 (1）两者作为函数的参数进行传递时：

​	基本数据类型传入的是数据的副本，原数据的更改不会影响传入后的数据。

​	引用数据类型传入的是数据的引用地址，原数据的更改会影响传入后的数据。

（2）两者在内存中的存储位置：

​	基本数据类型存储在栈中。

​	引用数据类型在栈中存储了指针，该指针指向的数据实体存储在堆中。

 

#### 5、判断数据类型的方法有哪些？

（1）利用typeof可以判断数据的类型；

（2）A instanceof B可以用来判断A是否为B的实例，但它不能检测 null 和 undefined；

（3）B.constructor == A可以判断A是否为B的原型，但constructor检测 Object与 instanceof不一样，还可以处理基本数据类型的检测。

（4）Object.prototype.toString.call()



#### 6、浅拷贝与深拷贝有何区别？如何实现？

浅拷贝只复制指向某个对象的指针，而不复制对象本身。浅拷贝的实现方式有： 

（1）Object.assign()：需注意的是目标对象只有一层的时候，是深拷贝；

（2）扩展运算符；

深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。深拷贝的实现方式有：

（1）手写遍历递归赋值；

（2）结合使用JSON.parse()和JSON.stringify()方法。 (arguments.callee())



#### 7、什么是执行上下文和执行栈

变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的 变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的 便是window对象)。

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。

在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制 权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。



#### 8、什么是作用域和作用域链

作用域可以理解为一个独立的地盘，可以理解为标识符所能生效的范围。作用域最大的用处 就是隔离变量，不同作用域下同名变量不会有冲突。ES6中有全局作用域、函数作用域和块级 作用域三层概念。

当一个变量在当前块级作用域中未被定义时，会向父级作用域(创建该函数的那个父级作用 域)寻找。如果父级仍未找到，就会再一层一层向上寻找，直到找到全局作用域为止。这种一层 一层的关系，就是作用域链 。



#### 9、作用域和执行上下文的区别是什么

1）函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；

2）函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。



#### 10、如何改变this指针的指向

可以使用apply、call、bind(柯里化)方法改变this指向(**并不会改变函数的作用域**)。比较如下：

（1）三者第一个参数都是this要指向的对象，也就是想指定的上下文，上下文就是指调用 函数的那个对象(没有就指向全局window)；

（2）apply和bind的第二个参数都是数组，call接收多个参数并用逗号隔开；

（3）apply和call只对原函数做改动，bind会返回新的函数(要生效还得再调用一次)。



### 题组3:

#### 1、如何理解同步和异步

同步：按照代码书写顺序一一执行处理指令的一种模式，上一段代码执行完才能执行下一段代码。

异步：可以理解为一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务。

JS之所以需要异步的原因在于JS是单线程运行的。常用的异步场景有：**定时器、ajax请求、事件绑定**。



#### 2、什么是 AJAX？如何实现？

ajax是一种能够实现局部网页刷新的技术，可以使网页异步刷新。

ajax的实现主要包括四个步骤：

（1）创建核心对象XMLhttpRequest；

```js
let xhr = new XMLHttpRequest();
```

（2）利用open方法打开与服务器的连接；

```js
xhr.open(method, url); // method： 代表请求的方式； url：代表请求的地址

// 设置请求头
xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded')
```

（3）利用send方法发送请求；（"POST"请求时，还需额外设置请求头）

```js
xhr.send();  // get请求没有请求体； post请求：xhr.send(body)
```

（4）监听服务器响应，接收返回值。

```js
xhr.onreadystatechange = function () {
	if(xhr.readystate === 4){
		if(xhr.status === 200 || xhr.status === 304){
			return xhr.responseText;//xhr.responseXML 接收xml格式的响应数据; xhr.responseText 接收文本格式的响应数据
		}
	}
}
```



#### 3、 实现异步的方式有哪些？

(1）回调函数模式：将需要异步执行的函数作为回调函数执行，其缺点在于处理复杂逻辑异步 逻辑时，会造成回调地狱(回调嵌套层数太多，代码结构混乱)；

（2）事件监听模式：采用事件驱动的思想，当某一事件发生时触发执行异步函数，其缺点在 于整个代码全部得变为事件驱动模式，难以分辨主流程；

（3）发布订阅模式：当异步任务执行完成时发布消息给信号中心，其他任务通过在信号中心 中订阅消息来确定自己是否开始执行；

（4）Promise(ES6)：Promise对象共有三种状态pending(初始化状态)、fulfilled(成功状 态)、rejected(失败状态)。

（5）async/await(ES7)：基于Promise实现的异步函数；

（6）利用生成器实现。



#### 4、怎么理解宏任务，微任务？

宏任务有：script(整体代码)、setTimeout、setInterval、I/O、页面渲染；

微任务有：Promise.then、Object.observe、MutationObserver。

执行顺序大致如下：

主线程任务——>宏任务——>微任务——>微任务里的宏任务——>.......——>直到任务全部完成



#### 5、 require/import 之间的区别？

（1）require是CommonJS语法，import是ES6语法；

（2）require只在后端服务器支持，import在高版本浏览器及Node中都可以支持；

（3）require引入的是原始导出值的复制，import则是导出值的引用；

（4）require时运行时动态加载，import是静态编译；

（5）require调用时默认不是严格模式，import则默认调用严格模式.



#### 6、原型和原型链是什么？

1、原型的概念

JavaScript的象中都包含了一个 [proto] 内部属性，这个属性所对应的就是自身的原型

2、原型链的概念

当一个对象调用自身不存在的属性/方法时，就会去自己 [proto] 关联的前辈 prototype 对象上去找，如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”。



#### 7、事件委托是什么？

事件委托，又名事件代理。事件委托就是利用事件冒泡，就是把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托也就没法实现了。



#### 8、解释一下变量的提升

变量的提升是JavaScript的默认行为，这意味着将所有变量声明移动到当前作用域的顶部，并且可以在声明之前使用变量。初始化不会被提升，提升仅作用于变量的声明。



#### 9、如何理解高阶函数？

JavaScript中的一切都是对象，包括函数。我们可以将变量作为参数传递给函数，函数也是如此。我们调用接受和或返回另一个函数称为高阶函数的函数。





## 四、React

### 题组1：

#### 1、 什么是React？

React 是 Facebook 在 2011 年开发的前端 JavaScript 库。 它遵循基于组件的方法，有助于构建可重用的UI组件。 它用于开发复杂和交互式的 Web 和移动 UI。 尽管它仅在 2015 年开源，但有一个很大的支持社区。



#### 2、React 有什么特点？

它使用虚拟DOM而不是真正的DOM。

它可以用服务器端渲染。

它遵循单向数据流或数据绑定。



#### 3、列出 React 的一些主要优点。

它提高了应用的性能，

可以方便地在客户端和服务器端使用。

由于 JSX，代码的可读性很好。

React 很容易与 Meteor，Angular 等其他框架集成。

使用React，编写UI测试用例变得非常容易。



#### 4、React 有哪些限制？

React 只是一个库，而不是一个完整的框架。

它的库非常庞大，需要时间来理解。

新手程序员可能很难理解。

编码变得复杂，因为它使用内联模板和 JSX。



#### 5、什么是 JSX？

JSX 是 JavaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。



#### 6、为什么浏览器无法读取 JSX？

浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript对象，然后再将其传给浏览器。



#### 7、如何理解“在 React 中，一切都是组件”这句话？

组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。



#### 8、解释 React 中 render() 的目的。

每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 form、group、div 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。



#### 9、什么是 Props？

Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。



#### 10、React 中的状态是什么？它是如何使用的？

状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 this.state()访问它们。



#### 11、React 组件生命周期的阶段是什么？

React 组件的生命周期有三个不同的阶段：

初始渲染阶段：这是组件即将开始其生命之旅并进入 DOM 的阶段。

更新阶段：一旦组件被添加到 DOM，它只有在 prop 或状态发生变化时才可能更新和重新渲染。这些只发生在这个阶段。

卸载阶段：这是组件生命周期的最后阶段，组件被销毁并从 DOM 中删除。



### 题组2：

#### 1、详细解释 React 组件的生命周期方法。

componentWillMount() – 在渲染之前执行，在客户端和服务器端都会执行。

componentDidMount() – 仅在第一次渲染后在客户端执行。

componentWillReceiveProps() – 当从父类接收到 props 并且在调用另一个渲染器之前调用。

shouldComponentUpdate() – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false。

componentWillUpdate() – 在 DOM 中进行渲染之前调用。

componentDidUpdate() – 在渲染发生后立即调用。

componentWillUnmount() – 从 DOM 卸载组件后调用。用于清理内存空间。



#### 2、React 中的事件是什么？

在 React 中，事件是对鼠标悬停、鼠标单击、按键等特定操作的触发反应。处理这些事件类似于处理 DOM 元素中的事件。但是有一些语法差异，如：

用驼峰命名法对事件命名而不是仅使用小写字母。

事件作为函数而不是字符串传递。

事件参数重包含一组特定于事件的属性。每个事件类型都包含自己的属性和行为，只能通过其事件处理程序访问。



#### 3、React 中的合成事件是什么？

合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。



#### 4、列出一些应该使用 Refs 的情况。

①需要管理焦点、选择文本或媒体播放时

②触发式动画

③与第三方 DOM 库集成



#### 5、什么是高阶组件（HOC）？

高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。



#### 6、你能用 HOC 做什么？

代码重用，逻辑和引导抽象

渲染劫持

状态抽象和控制

Props 控制



#### 7、什么是纯组件？

纯（Pure） 组件是可以编写的最简单、最快的组件。它们可以替换任何只有 render() 的组件。这些组件增强了代码的简单性和应用的性能。



#### 8、React 中 key 的重要性是什么？

key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能。



#### 9、什么是 React 路由？

React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和 流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发 单页 Web 应用。 React 路由有一个简单的API。



#### 10、为什么需要 React 中的路由？

Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添 加一个 Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图。



### 题组3：

#### 1、列出 React Router 的优点

就像 React 基于组件一样，在 React Router v4 中，API 是 ‘All About Components’。可以将 Router 可视化为单个根组件（BrowserRouter），其中我们将特定的子路由（route）包 起来。 无需手动设置历史值：在 React Router v4 中，我们要做的就是将路由包装在 BrowserRouter 组件中。包是分开的：共有三个包，分别用于Web、Native 和 Core。这使我们应用更加紧凑。基于类 似的编码风格很容易进行切换。



#### 2、state 和 props 有什么区别？

state 和 props都是普通的JavaScript对象。尽管它们两者都具有影响渲染输出的信息，但它 们在组件方面的功能不同。即：

props 是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读 性和不变性，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。

state 的主要作用是用于组件保存、控制以及修改自己的状态，它只能在 constructor 中初始 化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的 this.setState 来修改，修改 state 属性会导致组件的重新渲染。



#### 3、constructor 中 super 与 props 参数一起使用的目的是什么？

在调用方法之前，子类构造函数无法使用 this 引用 super() 。

在ES6中，在子类的 constructor 中必须先调用 super 才能引用 this 。

在 constructor 中可以使用 this.props



#### 4、使用 React Hooks 有什么优势？

hooks 是react 16.8 引入的特性，他允许你在不写class的情况下操作state 和react的其他特性。
hooks 只是多了一种写组件的方法，使编写一个组件更简单更方便，同时可以自定义hook把公共的逻辑提取出来，让逻辑在多个组件之间共享。

Hook 是什么？

Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。稍后我们将学习其他 Hook。

什么时候会用 Hook？

如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 ReactHooks的优点：

①无需复杂的DOM结构

②简洁易懂



#### 5、React 中的 StrictMode 是什么？

React的StrictMode是一种帮助程序组件，可以帮助您编写更好的react组件，您可以使用包 装一些组件， 并且基本上可以： 验证内部组件是否遵循某些推荐做法，如果不在控制台中，则会发出警告。

验证不赞成使用的方法，如果使用了严格模式，则会在控制台中警告您。

通过识别潜在风险来帮助您预防某些副作用。



#### 6、React Fiber 是什么？

React Fiber 并不是所谓的纤程（微线程、协程），而是一种基于浏览器的单线程调度算法， 背后的支持 API 是大名鼎鼎的：requestIdleCallback。 Fiberl是一种将 recocilation （递归 diff），拆分成无数个小任务的算法；它随时能够停止， 恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。



#### 7、解释 react diff 的原理。

把树形结构按照层级分解，只比较同级元素。 给列表结构的每个单元添加唯一的 key 属性，方便比较。 React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字） 合并操作， 调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 选择性子树渲 染。开发人员可以重写shouldComponentUpdate 提高 diff 的性能。



#### 8、setState 和 replaceState 的区别

setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖， 不会减少原来的状态 replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果 新状态属性减少，那么 state 中就没有这个状态了。



#### 9、React 中三种构建组件的方式？

React.createClass()、ES6 class 和无状态函数。



#### 10、应该在 React 组件的何处发起 Ajax 请求？

在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次 “挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。 更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将 尝试在一个未挂载的组件上调用setState，这将不起作用。 在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。



## 五、Vue

### 题组1：

#### 1、Vue 父组件向子组件传递数据？

通过 props。



#### 2、子组件向父组件传递事件？

$emit 方法



#### 3、 v-show 和 v-if 指令的共同点和不同点？

共同点：都能控制元素的显示和隐藏；

不同点：实现本质方法不同，v-show 本质就是通过控制 css 中的 display 设置为 none，控制隐藏，只会编译一次；v-if 是动态的向 DOM 树内添加或者删除 DOM 元素，若初始值为 false，就不会编译了。而且 v-if 不停的销毁和创建比较消耗性能。

总结：如果要频繁切换某节点，使用 v-show(切换开销比较小，初始开销较大)。如果不需要 频繁切换某节点使用 v-if（初始渲染开销较小，切换开销比较大）。



#### 4、如何让 CSS 只在当前组件中起作用？

在组件中的 style 前面加上 scoped



#### 5、 keep-alive 的作用是什么？

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。



#### 6、如何获取 dom？

ref="domName" 用法：this.$refs.domName



#### 7、说出几种 Vue 当中的指令和它的用法？

v-model 双向数据绑定；

v-for 循环；

v-if v-show 显示与隐藏；

v-on 事件；v-once: 只绑定一次。



#### 8、vue-loader 是什么？使用它的用途有哪些？

vue 文件的一个加载器，将 template/js/style 转换成 js 模块。

用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等。



#### 9、为什么使用 key？

需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点。

作用主要是为了高效的更新虚拟 DOM。



#### 10、axios 及安装？

请求后台资源的模块。npm install axios --save 装好， js 中使用 import 进来，然后 . get 或 . post。返回在. then 函数中如果成功，失败则是在 .catch 函数中。



### 题组2：

#### 1、v-modal 的使用?

v-model 用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：

v-bind 绑定一个 value 属性；

v-on 指令给当前元素绑定 input 事件。



#### 2、请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？

assets 文件夹是放静态资源；components 是放组件；router 是定义路由相关的配置; app.vue 是一个应用主组件；main.js 是入口文件。



#### 3、分别简述 computed 和 watch 的使用场景。

computed:

当一个属性受多个属性影响的时候就需要用到 computed

最典型的例子： 购物车商品结算的时候

watch:

当一条数据影响多条数据的时候就需要用 watch

例子：搜索数据



#### 4、$nextTick 的使用？

当你修改了 data 的值然后马上获取这个 dom 元素的值，是不能获取到更新后的值，你需要使用 $nextTick 这个回调，让修改后的 data 值渲染更新到 dom 元素之后在获取，才能成功。



#### 5、Vue 组件中 data 为什么必须是一个函数？

因为 JavaScript 的特性所导致，在 component 中，data 必须以函数的形式存在，不可以是对象。 组建中的 data 写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的 数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个 data，这样改 一个全都改了。



#### 6、Vue 中双向数据绑定是如何实现的？

Vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和 视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变； 核心：关于 Vue 双向数据绑定，其核心是 Object.defineProperty() 方法。



#### 7、v-if 和 v-for 的优先级？

当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重 复运行于每个 v-for 循环中。所以，不推荐 v-if 和 v-for 同时使用。 如果 v-if 和 v-for 一起用的话，vue 中的的会自动提示 v-if 应该放到外层去。



#### 8、Vue 的两个核心点？

数据驱动、组件系统

数据驱动：ViewModel，保证数据和视图的一致性。

组件系统：应用类 UI 可以看作全部是由组件树构成的。



#### 9、Vue 和 jQuery 的区别？

jQuery 是使用选择器（`$`）选取 DOM 对象，对其进行赋值、取值、事件绑定等操作，其 实和原生的 HTML 的区别只在于可以更方便的选取和操作 DOM 对象，而数据和界面是在一 起的。比如需要获取 label 标签的内容：`$`("lable").val();, 它还是依赖 DOM 元素的值。

Vue 则是通过 Vue 对象将数据和 View 完全分离开来了。对数据进行操作不再需要引用相应的 DOM 对象，可以说数据和 View 是分离的，他们通过 Vue 对象这个 vm 实现相互的绑定。这 就是传说中的 MVVM。



#### 10、引进组件的步骤？

在 template 中引入组件；

在 script 的第一行用 import 引入路径；

用 component 中写上组件名称。



### 题组3：

#### 1、 delete 和 Vue.delete 删除数组的区别？

delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。

Vue.delete 直接删除了数组 改变了数组的键值。



#### 2、SPA 首屏加载慢如何解决？

安装动态懒加载所需插件；使用 CDN 资源。



#### 3、Vue 里面 router-link 在电脑上有用，在安卓上没反应怎么解决？

Vue 路由在 Android 机上有问题，babel 问题，安装 babel polypill 插件解决。



#### 4、Vue2 中注册在 router-link 上事件无效解决方法？

使用 @click.native。原因：router-link 会阻止 click 事件，.native 指直接监听一个原 生事件。



#### 5、RouterLink 在 IE 和 Firefox 中不起作用（路由不跳转）的问题

方法一：只用 a 标签，不适用 button 标签；

方法二：使用 button 标签和Router.navigate 方法



#### 6、请说下封装 Vue 组件的过程？

1. 建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。
2. 准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。
3. 准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。
4. 封装完毕了，直接调用即可



#### 7、 Vue 更新数组时触发视图更新的方法？

push()；pop()；shift()；unshift()；splice()； sort()；reverse()



#### 8、Vue 的生命周期？

beforeCreate 、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed（创建、挂载、更新、卸载）

挂载中可以操作DOM，创建中不能操作DOM；常用挂载或者创建生命周期就行了



#### 9、虚拟 DOM 和 DIFF 算法？

将DOM抽象为虚拟DOM, 然后通过新旧虚拟DOM 这两个对象的差异(Diff算法),最终只把变化 的部分重新渲染,提高渲染效率的过程;

diff 是通过JS层面的计算，返回一个patch对象，即补丁对象，在通过特定的操作解析patch对 象，完成页面的重新渲染

#### 10、开发中常用的指令有哪些？

v-model:一般用在表达输入，很轻松的实现表单控件和数据的双向绑定

v-html：更新元素的innerHTML

v-show与v-if：条件渲染，注意二者区别

v-on:click:可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数

v-for：基于源数据多次渲染元素或模板

1.beforecreate:可以在加个loading事件，在加载实例是触发 2.created:初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用

3.mounted:挂载元素，获取到dom节点

4.updated:如果对数据统一处理，在这里写上相应函数

5.beforeDestroy:可以一个确认停止事件的确认框

6.nextTick:更新数据后立即操作dom

v-bind:当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM语法

v-bind:title=”msg”简写：title="msg"
